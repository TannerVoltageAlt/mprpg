{"files":{"pxt.json":"{\n    \"name\": \"pxt-button-combos\",\n    \"version\": \"0.0.24\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"combos.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": false,\n    \"supportedTargets\": [\n        \"arcade\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","README.md":"# pxt-button-combos\n\n## Reference\n\n### On Button Combination\n\nAdd a new combo to the game.\n\nCombos are represented by a string of characters that correspond to button presses,\nwhere u=up, d=down, l=left, r=right, a=A, and b=B. `+` can be used between characters to\nrequire them to be pressed at the same time.\n\n| controller button | value |\n|---| ---|\n| up | U |\n| down | D |\n| left | L |\n| right | R |\n| A | A |\n| B | B |\n\nThe sequence \"press a, followed by b, followed by down and right at the same time\" would\nbe represented by the string \"abd+r\".\n\nEach combo must be distinct; adding a new handler for a previously used combo\nwill overwrite the old handler.\n\n@param combo the combo move sequence: see full combo for examples.\n@param handler function to run when combo has been inputted.\n\n### Button Ids\n\nA piece of a button sequence. Can be text ``join``ed with buttons\nto create a full sequence for ``generateComboString``\n\n@param id the button to generate a string for\n\n### Remove Combo\n\nRemove a previously attached combo..\n\n@param combo combo to remove; see attachCombo for format.\n\n### Set Combo Timeout\n\nSet the amount of time between button presses before a combo is ended.\n\n@param t maximum amount of time between button presses that should trigger combo.\n\n### Combo Trigger\n\nSet the condition for when moves will trigger (attempt to run).\n\nBy default, this is set to TriggerType.Continuous, which will attempt to run\na combo each time a button is pressed.\n\n### On Special Combination\n\nAdd a new event that runs when a special code is entered.\n\nThe special code for this event is:\n>up, up, down, down, left, right, left, right, B, A\n\n@param handler event to run when the code is entered.\n\n## TODO\n\n- [x] Add a reference for your blocks here\n- [x] Add \"icon.png\" image (300x200) in the root folder\n- [x] Add \"- beta\" to the GitHub project description if you are still iterating it.\n- [x] Use \"pxt bump\" to create a tagged release on GitHub\n- [x] Get your package reviewed and approved https://arcade.makecode.com/packages/approval\n\nRead more at https://arcade.makecode.com/packages/build-your-own\n\n## License\n\nMIT\n\nCopyright 2019 Joey Wunderlich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n## Supported targets\n\n* for PXT/arcade\n(The metadata above is needed for package search.)\n","combos.ts":"enum TriggerType {\n    //% block=\"on each press\"\n    Continuous,\n    //% block=\"on menu press\"\n    Menu,\n    //% block=\"on timeout\"\n    Timeout,\n    // Event, // w/ `() => boolean` handler added below\n    //% block=\"never\"\n    Disabled\n}\n\n//% groups='[\"other\",\"Combos\"]'\nnamespace controller.combos {\n    export enum ID {\n        //% block=\"↑\"\n        up = 1 << 0,\n        //% block=\"↓\"\n        down = 1 << 1,\n        //% block=\"←\"\n        left = 1 << 2,\n        //% block=\"→\"\n        right = 1 << 3,\n        //% block=\"A\"\n        A = 1 << 4,\n        //% block=\"B\"\n        B = 1 << 5,\n        //menu = 1 << 6,\n        //% block=\"+\"\n        plus = -1\n    }\n\n    interface Combination {\n        c: number[];\n        h: () => void;\n    }\n\n    interface ComboState {\n        combinations: Combination[];\n        currState: boolean[];\n        maxCombo: number;\n        state: number[];\n        lastPressed: number;\n        triggerOn: TriggerType;\n        timeout: number;\n        countAsOne: number;\n        extendedCombos: boolean;\n    }\n\n    function init() {\n        const comboState = getComboState();\n        if (comboState) return;\n\n        setComboState({\n            combinations: [],\n            currState: [],\n            state: [],\n            maxCombo: 0,\n            extendedCombos: false,\n            timeout: 0,\n            countAsOne: 60,\n            triggerOn: TriggerType.Continuous,\n            lastPressed: game.runtime()\n        });\n\n        game.onUpdate(function () {\n            const s = getComboState();\n            if (s.timeout > 0 && game.runtime() - s.lastPressed > s.timeout) {\n                if (s.triggerOn === TriggerType.Timeout) {\n                    inputMove();\n                }\n                s.state = [];\n            }\n            if (s.triggerOn === TriggerType.Menu && controller.menu.isPressed()) {\n                inputMove();\n            }\n            let newButtonPressed = false;\n\n            const pressed = checkButton(controller.up, ID.up)\n                | checkButton(controller.down, ID.down)\n                | checkButton(controller.left, ID.left)\n                | checkButton(controller.right, ID.right)\n                | checkButton(controller.A, ID.A)\n                | checkButton(controller.B, ID.B)\n\n            if (pressed) {\n                if (game.runtime() - s.lastPressed <= s.countAsOne) {\n                    if (!(s.state[s.state.length - 1] & pressed)) {\n                        s.state[s.state.length - 1] |= pressed;\n                        newButtonPressed = true;\n                    }\n                } else {\n                    s.state.push(pressed);\n                    s.lastPressed = game.runtime();\n                    newButtonPressed = true;\n                }\n            }\n\n            if (s.state.length > s.maxCombo) {\n                s.state.shift();\n            }\n\n            if (s.triggerOn === TriggerType.Continuous && newButtonPressed) {\n                inputMove()\n            }\n        })\n    }\n\n    function inputMove() {\n        const s = getComboState();\n        let validMoves: Combination[] = s.combinations\n            .filter(move => checkMove(move.c, s.state))\n            .sort((one, two) => two.c.length - one.c.length);\n\n        if (s.extendedCombos) {\n            validMoves\n                .forEach(move => move.h())\n        } else {\n            const move = validMoves.get(0);\n            if (move) {\n                s.state = [];\n                move.h();\n            }\n        }\n    }\n\n    function checkButton(b: controller.Button, id: number): number {\n        const s = getComboState();\n        if (b.isPressed()) {\n            if (!s.currState[b.id]) {\n                s.currState[b.id] = true;\n                return id;\n            }\n        } else {\n            s.currState[b.id] = false;\n        }\n        return 0;\n    }\n\n    function checkMove(move: number[], actual: number[], exact?: boolean): boolean {\n        const offset = actual.length - move.length;\n        if (offset < 0 || (exact && move.length != actual.length))\n            return false;\n\n        for (let i = 0; i < move.length; i++) {\n            if (move[i] != actual[i + offset]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function toArray(combo: string): number[] {\n        let output: number[] = [];\n        let combine = false;\n\n        for (let i = 0; i < combo.length; i++) {\n            let curr = charToId(combo.charAt(i));\n            if (curr === ID.plus) {\n                combine = true;\n            } else if (curr) {\n                if (combine) {\n                    output[output.length - 1] |= curr;\n                    combine = false;\n                } else {\n                    output.push(curr);\n                }\n            }\n        }\n\n        return output;\n    }\n\n    function charToId(letter: string): ID {\n        switch (letter) {\n            case \"u\": case \"U\": case \"↑\":\n                return ID.up;\n            case \"d\": case \"D\": case \"↓\":\n                return ID.down;\n            case \"l\": case \"L\": case \"←\":\n                return ID.left;\n            case \"r\": case \"R\": case \"→\":\n                return ID.right;\n            case \"a\": case \"A\":\n                return ID.A;\n            case \"b\": case \"B\":\n                return ID.B;\n            case \"+\":\n                return ID.plus;\n            default:\n                return 0;\n        }\n    }\n\n\n    /**\n     * A piece of a button sequence. Can be text ``join``ed with buttons\n     * to create a full sequence for ``generateComboString``\n     * \n     * @param id the button to generate a string for\n     */\n    //% group=\"Combos\"\n    //% weight=90\n    //% blockId=buttonCombosIdToString block=\"%id\"\n    export function idToString(id: ID): string {\n        let output = checkId(id, ID.up, \"U\", \"\");\n        output = checkId(id, ID.down, \"D\", output);\n        output = checkId(id, ID.left, \"L\", output);\n        output = checkId(id, ID.right, \"R\", output);\n        output = checkId(id, ID.A, \"A\", output);\n        return checkId(id, ID.B, \"B\", output);\n\n        function checkId(id: ID, toMatch: ID, char: string, output: string) {\n            if (!(toMatch & id))\n                return output;\n\n            if (output.length == 0)\n                return char;\n            else\n                return output + \"+\" + char;\n        }\n    }\n\n    /**\n     * Returns a combo string matching the next `length` inputs\n     * \n     * This is primarily intended to help in pre game development; that is,\n     * using it to generate strings for the combos you want to add into your game.\n     * \n     * @param length length of combo to track\n     */\n    export function generateComboString(length: number): string {\n        init();\n        const s = getComboState();\n\n        s.maxCombo = length;\n        const originalTrigger = s.triggerOn;\n        s.triggerOn = TriggerType.Disabled;\n        while (s.state.length < s.maxCombo)\n            pause(1);\n\n        const output = s.state\n            .map(n => idToString(n))\n            .join(\"\");\n\n        s.state = [];\n        s.maxCombo = 0;\n        s.combinations\n            .forEach(c => s.maxCombo = Math.max(s.maxCombo, c.c.length));\n        s.triggerOn = originalTrigger;\n        return output;\n    }\n\n    /**\n     * Add a new combo to the game.\n     * \n     * Combos are represented by a string of characters that correspond to button presses,\n     * where u=up, d=down, l=left, r=right, a=A, and b=B. `+` can be used between characters to\n     * require them to be pressed at the same time.\n     * \n     * The sequence \"press a, followed by b, followed by down and right at the same time\" would\n     * be represented the string \"abd+r\"\n     * \n     * Each combo must be distinct; adding a new handler for a previously used combo\n     * will overwrite the old handler\n     * \n     * @param combo the combo move sequence: see full combo for examples\n     * @param handler function to run when combo has been inputted\n     */\n    //% group=\"Combos\"\n    //% weight=100\n    //% blockId=buttonCombosAttach block=\"on button combination %combo\"\n    export function attachCombo(combo: string, handler: () => void) {\n        init();\n        const s = getComboState();\n\n        if (!combo) return;\n        let c: number[] = toArray(combo);\n\n        for (let move of s.combinations) {\n            if (checkMove(move.c, c, true)) {\n                move.h = handler;\n                return;\n            }\n        }\n\n        s.maxCombo = Math.max(combo.length, s.maxCombo);\n        s.combinations.push(\n            {\n                c: c,\n                h: handler\n            }\n        );\n    }\n\n    /**\n     * Add a new event that runs when a special code is entered.\n     * \n     * The special code for this event is:\n     * up, up, down, down, left, right, left, right, B, A\n     * \n     * @param handler event to run when the code is entered\n     */\n    //% group=\"Combos\"\n    //% weight=10\n    //% blockId=buttonCombosSpecialAttach block=\"on special combination\"\n    export function attachSpecialCode(handler: () => void) {\n        attachCombo(\"UUDDLRLRBA\", handler);\n    }\n\n    /**\n     * Remove a previously attached combo\n     * \n     * @param combo combo to remove; see attachCombo for format\n     */\n    //% group=\"Combos\"\n    //% weight=80\n    //% blockId=buttonCombosDetach block=\"remove combo %combo\"\n    export function detachCombo(combo: string) {\n        init();\n        const s = getComboState();\n        let c: number[] = toArray(combo);\n\n        for (let i = 0; i < s.combinations.length; i++) {\n            if (checkMove(s.combinations[i].c, c, true)) {\n                s.combinations.removeAt(i);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Set the amount of time between button presses before a combo is ended\n     * \n     * @param t maximum amount of time between button presses that should trigger combo\n     */\n    //% group=\"Combos\"\n    //% weight=70\n    //% blockId=buttonCombosTimeout block=\"set combo timeout to %t\"\n    export function setTimeout(t: number): void {\n        init();\n        const s = getComboState();\n        s.timeout = t;\n    }\n\n    /**\n     * Set the condition for when moves will trigger (attempt to run)\n     * \n     * By default, this is set to TriggerType.Continuous, which will attempt to run\n     * a combo each time a button is pressed\n     */\n    //% group=\"Combos\"\n    //% weight=60\n    //% blockId=buttonCombosTriggerType block=\"combo trigger %t\"\n    export function setTriggerType(t: TriggerType) {\n        init();\n        const s = getComboState();\n        s.triggerOn = t;\n    }\n\n    /**\n     * Set extended combo mode to be on or off\n     * \n     * If extended combo mode is on, allow multiple sequences to trigger from the same input;\n     * for example, with an input of \"ab\", it will trigger events for \"a\", \"b\", and \"ab\"\n     */\n    //% group=\"Combos\"\n    //% weight=50\n    //% blockId=buttonCombosSetExtendedComboMode block=\"set extended combo mode %on=toggleOnOff\"\n    export function setExtendedComboMode(on: boolean) {\n        init();\n        const s = getComboState();\n        s.extendedCombos = on;\n    }\n\n    export function setCountAsOnePressTimer(length: number) {\n        init();\n        const s = getComboState();\n        s.countAsOne = length;\n    }\n\n    function getComboState() {\n        return game.currentScene().data.buttonComboState as ComboState;\n    }\n\n    function setComboState(state: ComboState) {\n        game.currentScene().data.buttonComboState = state;\n    }\n}","test.ts":"// Tests: Append `/` to the opening line of comment to start test, return to /** to end\n\n// Test 1: General function\n/**\ncontroller.combos.setTimeout(1500);\ncontroller.combos.attachSpecialCode(function () {\n    game.splash(\"hi\");\n});\n\ncontroller.combos.attachCombo(\"uullrr\", function () {\n    game.splash(\"you uuddlred\");\n})\ncontroller.combos.attachCombo(\"uullrl\", function () {\n    controller.combos.detachCombo(\"uullrr\");\n    game.splash(\"disabled uullrr\");\n})\ncontroller.combos.attachCombo(\"aaaaaaa\", function () {\n    game.splash(\"argh!\");\n})\n\ncontroller.combos.attachCombo(\"a+b\", function () {\n    game.splash(\"multi button!\")\n})\n\n// maybe should handle multiple combos with a more clear ruleset?\n// controller.combos.attachCombo(\"a+l\", () => game.splash(\"hi\"))\ncontroller.combos.attachCombo(\"a+l+d\", function () {\n    game.splash(\"super multi button!\")\n})\n//*/\n\n// Test menu trigger\n/**\ncontroller.combos.setTriggerType(TriggerType.Menu)\ncontroller.combos.setTimeout(1500);\ncontroller.combos.attachSpecialCode(function () {\n    game.splash(\"hi\");\n});\n\ncontroller.combos.attachCombo(\"uullrr\", function () {\n    game.splash(\"you uuddlred\");\n})\ncontroller.combos.attachCombo(\"aaaaaaa\", function () {\n    game.splash(\"argh!\");\n})\n\ncontroller.combos.attachCombo(\"a+b\", function () {\n    game.splash(\"multi button!\")\n})\n//*/\n\n// Test Timeout trigger, handling of multiple valid combos (take longest move)\n/**\ncontroller.combos.setTriggerType(TriggerType.Timeout)\ncontroller.combos.setTimeout(500);\n\ncontroller.combos.attachCombo(\"bab\", function () {\n    game.splash(\"You pressed 'bab'\");\n})\n\ncontroller.combos.attachCombo(\"abab\", function () {\n    game.splash(\"You pressed 'abab'\");\n})\n//*/\n\n// test generate combo string\n/**\nwhile (true) {\n    game.splash(controller.combos.generateComboString(5));\n}\n//*/\n\n// full game test\n/**/\ntype ButtonLetter = \"u\" | \"d\" | \"l\" | \"r\" | \"a\" | \"b\" | \"+\";\nconst f = image.doubledFont(image.font8);\nmusic.setVolume(0)\n\ninfo.setScore(0);\ninfo.setLife(3)\n\ncontroller.combos.setTriggerType(TriggerType.Continuous);\ncontroller.combos.setTimeout(2000);\n\n\ngame.onUpdateInterval(6000, function () {\n    const combo = generateUniqueCombo(Math.randomRange(2, 5));\n    if (!combo) return;\n\n    const comboDisplay = comboTag(combo);\n\n    const comboSprite = sprites.create(comboDisplay, 1);\n    comboSprite.vx = -10;\n    comboSprite.x = screen.width;\n    comboSprite.y = Math.randomRange(comboSprite.height >> 1, screen.height - (comboSprite.height >> 1));\n    comboSprite.data = combo;\n\n    controller.combos.attachCombo(combo, () => {\n        comboSprite.vx = 0;\n        comboSprite.destroy(effects.fire);\n        info.changeScoreBy(1);\n        music.baDing.playUntilDone()\n    })\n});\n\ngame.onUpdate(() => {\n    sprites\n        .allOfKind(1)\n        .forEach(s => {\n            if (s.x <= 0) {\n                s.destroy();\n                info.changeLifeBy(-1);\n                music.wawawawaa.play();\n            }\n        });\n});\n\nsprites.onDestroyed(1, function (sprite: Sprite) {\n    controller.combos.detachCombo(sprite.data as string);\n});\n\nfunction comboTag(combo: string) {\n    const width = f.charWidth * combo.length;\n    const height = f.charHeight;\n\n    const comboDisplay = image.create(width + 4, height + 4);\n    comboDisplay.fill(0xC);\n    comboDisplay.fillRect(1, 1, width + 2, height + 2, 1);\n    comboDisplay.printCenter(comboToDisplay(combo), 2, Math.randomRange(2, 0xF), f);\n\n    return comboDisplay;\n}\n\nfunction generateUniqueCombo(difficulty: number) {\n    let attempts = 10;\n    do {\n        const combo = generateCombo(difficulty);\n        const alreadyExists = sprites\n            .allOfKind(1)\n            .some(s => s.data === combo);\n        if (!alreadyExists) {\n            return combo;\n        }\n    } while (attempts--);\n\n    return undefined;\n}\n\nfunction generateCombo(difficulty: number) {\n    const buttonLetters = [\"u\", \"d\", \"l\", \"r\", \"a\", \"b\"];\n    let output = \"\";\n    while (difficulty > 0) {\n        --difficulty;\n        let nextInput = Math.pickRandom(buttonLetters);\n\n        if (Math.percentChance(15)) {\n            --difficulty;\n            let secondButton = Math.pickRandom(buttonLetters);\n            while (nextInput == secondButton) {\n                secondButton = Math.pickRandom(buttonLetters);\n            }\n            nextInput += \"+\" + secondButton;\n        }\n\n        output += nextInput;\n    }\n\n    return output;\n}\n\nfunction comboToDisplay(combo: string) {\n    return combo\n        .split(\"\")\n        .map(c => letterToDisplay(c as ButtonLetter))\n        .join(\"\");\n}\n\nfunction letterToDisplay(letter: ButtonLetter) {\n    switch (letter) {\n        case \"u\": return \"↑\";\n        case \"d\": return \"↓\";\n        case \"l\": return \"←\";\n        case \"r\": return \"→\";\n        default: return letter;\n    }\n}\n//*/\n\n// extended combo mode test:\n\n/**\ncontroller.combos.setExtendedComboMode(true)\ncontroller.combos.attachCombo(\"a\", function () {\n    console.log(\"a\");\n})\ncontroller.combos.attachCombo(\"b\", function () {\n    console.log(\"b\");\n})\ncontroller.combos.attachCombo(\"ab\", function () {\n    console.log(\"ab\");\n})\n//*/\n"}}